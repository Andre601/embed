// Code generated by Prisma (prisma@1.26.4). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from 'graphql'
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from 'prisma-client-lib'
import { typeDefs } from './prisma-schema'

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U]

export interface Exists {
  connection: (where?: ConnectionWhereInput) => Promise<boolean>
  guild: (where?: GuildWhereInput) => Promise<boolean>
  guildBan: (where?: GuildBanWhereInput) => Promise<boolean>
  guildGuest: (where?: GuildGuestWhereInput) => Promise<boolean>
  profile: (where?: ProfileWhereInput) => Promise<boolean>
  theme: (where?: ThemeWhereInput) => Promise<boolean>
  themeColors: (where?: ThemeColorsWhereInput) => Promise<boolean>
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>
}

export interface Prisma {
  $exists: Exists
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>

  /**
   * Queries
   */

  connections: (
    args?: {
      where?: ConnectionWhereInput
      orderBy?: ConnectionOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => FragmentableArray<Connection>
  connectionsConnection: (
    args?: {
      where?: ConnectionWhereInput
      orderBy?: ConnectionOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => ConnectionConnectionPromise
  guild: (where: GuildWhereUniqueInput) => GuildPromise
  guilds: (
    args?: {
      where?: GuildWhereInput
      orderBy?: GuildOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => FragmentableArray<Guild>
  guildsConnection: (
    args?: {
      where?: GuildWhereInput
      orderBy?: GuildOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => GuildConnectionPromise
  guildBans: (
    args?: {
      where?: GuildBanWhereInput
      orderBy?: GuildBanOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => FragmentableArray<GuildBan>
  guildBansConnection: (
    args?: {
      where?: GuildBanWhereInput
      orderBy?: GuildBanOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => GuildBanConnectionPromise
  guildGuests: (
    args?: {
      where?: GuildGuestWhereInput
      orderBy?: GuildGuestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => FragmentableArray<GuildGuest>
  guildGuestsConnection: (
    args?: {
      where?: GuildGuestWhereInput
      orderBy?: GuildGuestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => GuildGuestConnectionPromise
  profile: (where: ProfileWhereUniqueInput) => ProfilePromise
  profiles: (
    args?: {
      where?: ProfileWhereInput
      orderBy?: ProfileOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => FragmentableArray<Profile>
  profilesConnection: (
    args?: {
      where?: ProfileWhereInput
      orderBy?: ProfileOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => ProfileConnectionPromise
  theme: (where: ThemeWhereUniqueInput) => ThemePromise
  themes: (
    args?: {
      where?: ThemeWhereInput
      orderBy?: ThemeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => FragmentableArray<Theme>
  themesConnection: (
    args?: {
      where?: ThemeWhereInput
      orderBy?: ThemeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => ThemeConnectionPromise
  themeColorses: (
    args?: {
      where?: ThemeColorsWhereInput
      orderBy?: ThemeColorsOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => FragmentableArray<ThemeColors>
  themeColorsesConnection: (
    args?: {
      where?: ThemeColorsWhereInput
      orderBy?: ThemeColorsOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => ThemeColorsConnectionPromise
  node: (args: { id: ID_Output }) => Node

  /**
   * Mutations
   */

  createConnection: (data: ConnectionCreateInput) => ConnectionPromise
  updateManyConnections: (
    args: {
      data: ConnectionUpdateManyMutationInput
      where?: ConnectionWhereInput
    }
  ) => BatchPayloadPromise
  deleteManyConnections: (where?: ConnectionWhereInput) => BatchPayloadPromise
  createGuild: (data: GuildCreateInput) => GuildPromise
  updateGuild: (
    args: {
      data: GuildUpdateInput
      where: GuildWhereUniqueInput
    }
  ) => GuildPromise
  upsertGuild: (
    args: {
      where: GuildWhereUniqueInput
      create: GuildCreateInput
      update: GuildUpdateInput
    }
  ) => GuildPromise
  deleteGuild: (where: GuildWhereUniqueInput) => GuildPromise
  deleteManyGuilds: (where?: GuildWhereInput) => BatchPayloadPromise
  createGuildBan: (data: GuildBanCreateInput) => GuildBanPromise
  updateManyGuildBans: (
    args: {
      data: GuildBanUpdateManyMutationInput
      where?: GuildBanWhereInput
    }
  ) => BatchPayloadPromise
  deleteManyGuildBans: (where?: GuildBanWhereInput) => BatchPayloadPromise
  createGuildGuest: (data: GuildGuestCreateInput) => GuildGuestPromise
  updateManyGuildGuests: (
    args: {
      data: GuildGuestUpdateManyMutationInput
      where?: GuildGuestWhereInput
    }
  ) => BatchPayloadPromise
  deleteManyGuildGuests: (where?: GuildGuestWhereInput) => BatchPayloadPromise
  createProfile: (data: ProfileCreateInput) => ProfilePromise
  updateProfile: (
    args: {
      data: ProfileUpdateInput
      where: ProfileWhereUniqueInput
    }
  ) => ProfilePromise
  updateManyProfiles: (
    args: {
      data: ProfileUpdateManyMutationInput
      where?: ProfileWhereInput
    }
  ) => BatchPayloadPromise
  upsertProfile: (
    args: {
      where: ProfileWhereUniqueInput
      create: ProfileCreateInput
      update: ProfileUpdateInput
    }
  ) => ProfilePromise
  deleteProfile: (where: ProfileWhereUniqueInput) => ProfilePromise
  deleteManyProfiles: (where?: ProfileWhereInput) => BatchPayloadPromise
  createTheme: (data: ThemeCreateInput) => ThemePromise
  updateTheme: (
    args: {
      data: ThemeUpdateInput
      where: ThemeWhereUniqueInput
    }
  ) => ThemePromise
  updateManyThemes: (
    args: {
      data: ThemeUpdateManyMutationInput
      where?: ThemeWhereInput
    }
  ) => BatchPayloadPromise
  upsertTheme: (
    args: {
      where: ThemeWhereUniqueInput
      create: ThemeCreateInput
      update: ThemeUpdateInput
    }
  ) => ThemePromise
  deleteTheme: (where: ThemeWhereUniqueInput) => ThemePromise
  deleteManyThemes: (where?: ThemeWhereInput) => BatchPayloadPromise
  createThemeColors: (data: ThemeColorsCreateInput) => ThemeColorsPromise
  updateManyThemeColorses: (
    args: {
      data: ThemeColorsUpdateManyMutationInput
      where?: ThemeColorsWhereInput
    }
  ) => BatchPayloadPromise
  deleteManyThemeColorses: (
    where?: ThemeColorsWhereInput
  ) => BatchPayloadPromise

  /**
   * Subscriptions
   */

  $subscribe: Subscription
}

export interface Subscription {
  connection: (
    where?: ConnectionSubscriptionWhereInput
  ) => ConnectionSubscriptionPayloadSubscription
  guild: (
    where?: GuildSubscriptionWhereInput
  ) => GuildSubscriptionPayloadSubscription
  guildBan: (
    where?: GuildBanSubscriptionWhereInput
  ) => GuildBanSubscriptionPayloadSubscription
  guildGuest: (
    where?: GuildGuestSubscriptionWhereInput
  ) => GuildGuestSubscriptionPayloadSubscription
  profile: (
    where?: ProfileSubscriptionWhereInput
  ) => ProfileSubscriptionPayloadSubscription
  theme: (
    where?: ThemeSubscriptionWhereInput
  ) => ThemeSubscriptionPayloadSubscription
  themeColors: (
    where?: ThemeColorsSubscriptionWhereInput
  ) => ThemeColorsSubscriptionPayloadSubscription
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T
}

/**
 * Types
 */

export type GuildGuestOrderByInput =
  | 'nickname_ASC'
  | 'nickname_DESC'
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'

export type GuildBanOrderByInput =
  | 'type_ASC'
  | 'type_DESC'
  | 'data_ASC'
  | 'data_DESC'
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'

export type GuildOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'

export type ProfileOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'username_ASC'
  | 'username_DESC'
  | 'avatarURL_ASC'
  | 'avatarURL_DESC'
  | 'email_ASC'
  | 'email_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'

export type ThemeOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'css_ASC'
  | 'css_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'

export type ThemeColorsOrderByInput =
  | 'primary_ASC'
  | 'primary_DESC'
  | 'accent_ASC'
  | 'accent_DESC'
  | 'background_ASC'
  | 'background_DESC'
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'

export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED'

export type ConnectionOrderByInput =
  | 'type_ASC'
  | 'type_DESC'
  | 'data_ASC'
  | 'data_DESC'
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'

export interface ProfileCreateInput {
  username: String
  avatarURL: String
  connections?: ConnectionCreateManyInput
  email?: String
}

export interface ConnectionWhereInput {
  type?: String
  type_not?: String
  type_in?: String[] | String
  type_not_in?: String[] | String
  type_lt?: String
  type_lte?: String
  type_gt?: String
  type_gte?: String
  type_contains?: String
  type_not_contains?: String
  type_starts_with?: String
  type_not_starts_with?: String
  type_ends_with?: String
  type_not_ends_with?: String
  data?: String
  data_not?: String
  data_in?: String[] | String
  data_not_in?: String[] | String
  data_lt?: String
  data_lte?: String
  data_gt?: String
  data_gte?: String
  data_contains?: String
  data_not_contains?: String
  data_starts_with?: String
  data_not_starts_with?: String
  data_ends_with?: String
  data_not_ends_with?: String
  AND?: ConnectionWhereInput[] | ConnectionWhereInput
  OR?: ConnectionWhereInput[] | ConnectionWhereInput
  NOT?: ConnectionWhereInput[] | ConnectionWhereInput
}

export interface ThemeUpdateOneWithoutGuildInput {
  create?: ThemeCreateWithoutGuildInput
  update?: ThemeUpdateWithoutGuildDataInput
  upsert?: ThemeUpsertWithoutGuildInput
  delete?: Boolean
  disconnect?: Boolean
  connect?: ThemeWhereUniqueInput
}

export type GuildWhereUniqueInput = AtLeastOne<{
  id: ID_Input
}>

export interface GuildCreateOneWithoutGuestsInput {
  create?: GuildCreateWithoutGuestsInput
  connect?: GuildWhereUniqueInput
}

export interface GuildBanUpdateManyWithoutGuildInput {
  create?: GuildBanCreateWithoutGuildInput[] | GuildBanCreateWithoutGuildInput
  deleteMany?: GuildBanScalarWhereInput[] | GuildBanScalarWhereInput
  updateMany?:
    | GuildBanUpdateManyWithWhereNestedInput[]
    | GuildBanUpdateManyWithWhereNestedInput
}

export interface GuildGuestCreateInput {
  guild: GuildCreateOneWithoutGuestsInput
  profile: ProfileCreateOneInput
  nickname?: String
}

export interface ThemeUpdateWithoutGuildDataInput {
  css?: String
  colors?: ThemeColorsUpdateOneRequiredInput
}

export interface GuildBanUpdateManyMutationInput {
  type?: String
  data?: String
}

export interface GuildGuestWhereInput {
  guild?: GuildWhereInput
  profile?: ProfileWhereInput
  nickname?: String
  nickname_not?: String
  nickname_in?: String[] | String
  nickname_not_in?: String[] | String
  nickname_lt?: String
  nickname_lte?: String
  nickname_gt?: String
  nickname_gte?: String
  nickname_contains?: String
  nickname_not_contains?: String
  nickname_starts_with?: String
  nickname_not_starts_with?: String
  nickname_ends_with?: String
  nickname_not_ends_with?: String
  AND?: GuildGuestWhereInput[] | GuildGuestWhereInput
  OR?: GuildGuestWhereInput[] | GuildGuestWhereInput
  NOT?: GuildGuestWhereInput[] | GuildGuestWhereInput
}

export interface GuildCreateWithoutBansInput {
  theme?: ThemeCreateOneWithoutGuildInput
  guests?: GuildGuestCreateManyWithoutGuildInput
}

export interface ThemeWhereInput {
  id?: ID_Input
  id_not?: ID_Input
  id_in?: ID_Input[] | ID_Input
  id_not_in?: ID_Input[] | ID_Input
  id_lt?: ID_Input
  id_lte?: ID_Input
  id_gt?: ID_Input
  id_gte?: ID_Input
  id_contains?: ID_Input
  id_not_contains?: ID_Input
  id_starts_with?: ID_Input
  id_not_starts_with?: ID_Input
  id_ends_with?: ID_Input
  id_not_ends_with?: ID_Input
  guild?: GuildWhereInput
  css?: String
  css_not?: String
  css_in?: String[] | String
  css_not_in?: String[] | String
  css_lt?: String
  css_lte?: String
  css_gt?: String
  css_gte?: String
  css_contains?: String
  css_not_contains?: String
  css_starts_with?: String
  css_not_starts_with?: String
  css_ends_with?: String
  css_not_ends_with?: String
  colors?: ThemeColorsWhereInput
  AND?: ThemeWhereInput[] | ThemeWhereInput
  OR?: ThemeWhereInput[] | ThemeWhereInput
  NOT?: ThemeWhereInput[] | ThemeWhereInput
}

export interface GuildBanWhereInput {
  guild?: GuildWhereInput
  type?: String
  type_not?: String
  type_in?: String[] | String
  type_not_in?: String[] | String
  type_lt?: String
  type_lte?: String
  type_gt?: String
  type_gte?: String
  type_contains?: String
  type_not_contains?: String
  type_starts_with?: String
  type_not_starts_with?: String
  type_ends_with?: String
  type_not_ends_with?: String
  data?: String
  data_not?: String
  data_in?: String[] | String
  data_not_in?: String[] | String
  data_lt?: String
  data_lte?: String
  data_gt?: String
  data_gte?: String
  data_contains?: String
  data_not_contains?: String
  data_starts_with?: String
  data_not_starts_with?: String
  data_ends_with?: String
  data_not_ends_with?: String
  AND?: GuildBanWhereInput[] | GuildBanWhereInput
  OR?: GuildBanWhereInput[] | GuildBanWhereInput
  NOT?: GuildBanWhereInput[] | GuildBanWhereInput
}

export interface ThemeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType
  updatedFields_contains?: String
  updatedFields_contains_every?: String[] | String
  updatedFields_contains_some?: String[] | String
  node?: ThemeWhereInput
  AND?: ThemeSubscriptionWhereInput[] | ThemeSubscriptionWhereInput
  OR?: ThemeSubscriptionWhereInput[] | ThemeSubscriptionWhereInput
  NOT?: ThemeSubscriptionWhereInput[] | ThemeSubscriptionWhereInput
}

export interface ConnectionCreateInput {
  type: String
  data: String
}

export interface GuildGuestSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType
  updatedFields_contains?: String
  updatedFields_contains_every?: String[] | String
  updatedFields_contains_some?: String[] | String
  node?: GuildGuestWhereInput
  AND?: GuildGuestSubscriptionWhereInput[] | GuildGuestSubscriptionWhereInput
  OR?: GuildGuestSubscriptionWhereInput[] | GuildGuestSubscriptionWhereInput
  NOT?: GuildGuestSubscriptionWhereInput[] | GuildGuestSubscriptionWhereInput
}

export interface ConnectionUpdateManyMutationInput {
  type?: String
  data?: String
}

export interface GuildSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType
  updatedFields_contains?: String
  updatedFields_contains_every?: String[] | String
  updatedFields_contains_some?: String[] | String
  node?: GuildWhereInput
  AND?: GuildSubscriptionWhereInput[] | GuildSubscriptionWhereInput
  OR?: GuildSubscriptionWhereInput[] | GuildSubscriptionWhereInput
  NOT?: GuildSubscriptionWhereInput[] | GuildSubscriptionWhereInput
}

export interface GuildCreateOneWithoutBansInput {
  create?: GuildCreateWithoutBansInput
  connect?: GuildWhereUniqueInput
}

export interface ThemeColorsUpdateManyMutationInput {
  primary?: String
  accent?: String
  background?: String
}

export interface GuildBanCreateInput {
  guild: GuildCreateOneWithoutBansInput
  type: String
  data: String
}

export interface GuildUpsertWithoutThemeInput {
  update: GuildUpdateWithoutThemeDataInput
  create: GuildCreateWithoutThemeInput
}

export interface GuildCreateInput {
  theme?: ThemeCreateOneWithoutGuildInput
  guests?: GuildGuestCreateManyWithoutGuildInput
  bans?: GuildBanCreateManyWithoutGuildInput
}

export interface GuildUpdateOneRequiredWithoutThemeInput {
  create?: GuildCreateWithoutThemeInput
  update?: GuildUpdateWithoutThemeDataInput
  upsert?: GuildUpsertWithoutThemeInput
  connect?: GuildWhereUniqueInput
}

export interface ThemeCreateOneWithoutGuildInput {
  create?: ThemeCreateWithoutGuildInput
  connect?: ThemeWhereUniqueInput
}

export interface GuildCreateWithoutThemeInput {
  guests?: GuildGuestCreateManyWithoutGuildInput
  bans?: GuildBanCreateManyWithoutGuildInput
}

export interface ThemeCreateWithoutGuildInput {
  css: String
  colors: ThemeColorsCreateOneInput
}

export interface ThemeCreateInput {
  guild: GuildCreateOneWithoutThemeInput
  css: String
  colors: ThemeColorsCreateOneInput
}

export interface ThemeColorsCreateOneInput {
  create?: ThemeColorsCreateInput
}

export interface ProfileUpdateManyMutationInput {
  username?: String
  avatarURL?: String
  email?: String
}

export interface ThemeColorsCreateInput {
  primary: String
  accent: String
  background: String
}

export interface ConnectionUpdateManyWithWhereNestedInput {
  where: ConnectionScalarWhereInput
  data: ConnectionUpdateManyDataInput
}

export interface GuildGuestCreateManyWithoutGuildInput {
  create?:
    | GuildGuestCreateWithoutGuildInput[]
    | GuildGuestCreateWithoutGuildInput
}

export type ThemeWhereUniqueInput = AtLeastOne<{
  id: ID_Input
}>

export interface GuildGuestCreateWithoutGuildInput {
  profile: ProfileCreateOneInput
  nickname?: String
}

export interface ProfileUpdateInput {
  username?: String
  avatarURL?: String
  connections?: ConnectionUpdateManyInput
  email?: String
}

export interface ProfileCreateOneInput {
  create?: ProfileCreateInput
  connect?: ProfileWhereUniqueInput
}

export interface GuildCreateWithoutGuestsInput {
  theme?: ThemeCreateOneWithoutGuildInput
  bans?: GuildBanCreateManyWithoutGuildInput
}

export interface GuildBanUpdateManyDataInput {
  type?: String
  data?: String
}

export interface GuildWhereInput {
  id?: ID_Input
  id_not?: ID_Input
  id_in?: ID_Input[] | ID_Input
  id_not_in?: ID_Input[] | ID_Input
  id_lt?: ID_Input
  id_lte?: ID_Input
  id_gt?: ID_Input
  id_gte?: ID_Input
  id_contains?: ID_Input
  id_not_contains?: ID_Input
  id_starts_with?: ID_Input
  id_not_starts_with?: ID_Input
  id_ends_with?: ID_Input
  id_not_ends_with?: ID_Input
  theme?: ThemeWhereInput
  guests_every?: GuildGuestWhereInput
  guests_some?: GuildGuestWhereInput
  guests_none?: GuildGuestWhereInput
  bans_every?: GuildBanWhereInput
  bans_some?: GuildBanWhereInput
  bans_none?: GuildBanWhereInput
  AND?: GuildWhereInput[] | GuildWhereInput
  OR?: GuildWhereInput[] | GuildWhereInput
  NOT?: GuildWhereInput[] | GuildWhereInput
}

export interface ConnectionCreateManyInput {
  create?: ConnectionCreateInput[] | ConnectionCreateInput
}

export interface ProfileWhereInput {
  id?: ID_Input
  id_not?: ID_Input
  id_in?: ID_Input[] | ID_Input
  id_not_in?: ID_Input[] | ID_Input
  id_lt?: ID_Input
  id_lte?: ID_Input
  id_gt?: ID_Input
  id_gte?: ID_Input
  id_contains?: ID_Input
  id_not_contains?: ID_Input
  id_starts_with?: ID_Input
  id_not_starts_with?: ID_Input
  id_ends_with?: ID_Input
  id_not_ends_with?: ID_Input
  username?: String
  username_not?: String
  username_in?: String[] | String
  username_not_in?: String[] | String
  username_lt?: String
  username_lte?: String
  username_gt?: String
  username_gte?: String
  username_contains?: String
  username_not_contains?: String
  username_starts_with?: String
  username_not_starts_with?: String
  username_ends_with?: String
  username_not_ends_with?: String
  avatarURL?: String
  avatarURL_not?: String
  avatarURL_in?: String[] | String
  avatarURL_not_in?: String[] | String
  avatarURL_lt?: String
  avatarURL_lte?: String
  avatarURL_gt?: String
  avatarURL_gte?: String
  avatarURL_contains?: String
  avatarURL_not_contains?: String
  avatarURL_starts_with?: String
  avatarURL_not_starts_with?: String
  avatarURL_ends_with?: String
  avatarURL_not_ends_with?: String
  connections_every?: ConnectionWhereInput
  connections_some?: ConnectionWhereInput
  connections_none?: ConnectionWhereInput
  email?: String
  email_not?: String
  email_in?: String[] | String
  email_not_in?: String[] | String
  email_lt?: String
  email_lte?: String
  email_gt?: String
  email_gte?: String
  email_contains?: String
  email_not_contains?: String
  email_starts_with?: String
  email_not_starts_with?: String
  email_ends_with?: String
  email_not_ends_with?: String
  AND?: ProfileWhereInput[] | ProfileWhereInput
  OR?: ProfileWhereInput[] | ProfileWhereInput
  NOT?: ProfileWhereInput[] | ProfileWhereInput
}

export interface GuildBanCreateManyWithoutGuildInput {
  create?: GuildBanCreateWithoutGuildInput[] | GuildBanCreateWithoutGuildInput
}

export interface GuildBanSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType
  updatedFields_contains?: String
  updatedFields_contains_every?: String[] | String
  updatedFields_contains_some?: String[] | String
  node?: GuildBanWhereInput
  AND?: GuildBanSubscriptionWhereInput[] | GuildBanSubscriptionWhereInput
  OR?: GuildBanSubscriptionWhereInput[] | GuildBanSubscriptionWhereInput
  NOT?: GuildBanSubscriptionWhereInput[] | GuildBanSubscriptionWhereInput
}

export interface GuildBanCreateWithoutGuildInput {
  type: String
  data: String
}

export interface ThemeUpdateManyMutationInput {
  css?: String
}

export interface GuildUpdateInput {
  theme?: ThemeUpdateOneWithoutGuildInput
  guests?: GuildGuestUpdateManyWithoutGuildInput
  bans?: GuildBanUpdateManyWithoutGuildInput
}

export interface ThemeUpdateInput {
  guild?: GuildUpdateOneRequiredWithoutThemeInput
  css?: String
  colors?: ThemeColorsUpdateOneRequiredInput
}

export interface GuildBanUpdateManyWithWhereNestedInput {
  where: GuildBanScalarWhereInput
  data: GuildBanUpdateManyDataInput
}

export type ProfileWhereUniqueInput = AtLeastOne<{
  id: ID_Input
}>

export interface GuildBanScalarWhereInput {
  type?: String
  type_not?: String
  type_in?: String[] | String
  type_not_in?: String[] | String
  type_lt?: String
  type_lte?: String
  type_gt?: String
  type_gte?: String
  type_contains?: String
  type_not_contains?: String
  type_starts_with?: String
  type_not_starts_with?: String
  type_ends_with?: String
  type_not_ends_with?: String
  data?: String
  data_not?: String
  data_in?: String[] | String
  data_not_in?: String[] | String
  data_lt?: String
  data_lte?: String
  data_gt?: String
  data_gte?: String
  data_contains?: String
  data_not_contains?: String
  data_starts_with?: String
  data_not_starts_with?: String
  data_ends_with?: String
  data_not_ends_with?: String
  AND?: GuildBanScalarWhereInput[] | GuildBanScalarWhereInput
  OR?: GuildBanScalarWhereInput[] | GuildBanScalarWhereInput
  NOT?: GuildBanScalarWhereInput[] | GuildBanScalarWhereInput
}

export interface ConnectionScalarWhereInput {
  type?: String
  type_not?: String
  type_in?: String[] | String
  type_not_in?: String[] | String
  type_lt?: String
  type_lte?: String
  type_gt?: String
  type_gte?: String
  type_contains?: String
  type_not_contains?: String
  type_starts_with?: String
  type_not_starts_with?: String
  type_ends_with?: String
  type_not_ends_with?: String
  data?: String
  data_not?: String
  data_in?: String[] | String
  data_not_in?: String[] | String
  data_lt?: String
  data_lte?: String
  data_gt?: String
  data_gte?: String
  data_contains?: String
  data_not_contains?: String
  data_starts_with?: String
  data_not_starts_with?: String
  data_ends_with?: String
  data_not_ends_with?: String
  AND?: ConnectionScalarWhereInput[] | ConnectionScalarWhereInput
  OR?: ConnectionScalarWhereInput[] | ConnectionScalarWhereInput
  NOT?: ConnectionScalarWhereInput[] | ConnectionScalarWhereInput
}

export interface ThemeColorsUpdateOneRequiredInput {
  create?: ThemeColorsCreateInput
  update?: ThemeColorsUpdateDataInput
  upsert?: ThemeColorsUpsertNestedInput
}

export interface GuildGuestUpdateManyMutationInput {
  nickname?: String
}

export interface ThemeColorsUpdateDataInput {
  primary?: String
  accent?: String
  background?: String
}

export interface ThemeColorsWhereInput {
  primary?: String
  primary_not?: String
  primary_in?: String[] | String
  primary_not_in?: String[] | String
  primary_lt?: String
  primary_lte?: String
  primary_gt?: String
  primary_gte?: String
  primary_contains?: String
  primary_not_contains?: String
  primary_starts_with?: String
  primary_not_starts_with?: String
  primary_ends_with?: String
  primary_not_ends_with?: String
  accent?: String
  accent_not?: String
  accent_in?: String[] | String
  accent_not_in?: String[] | String
  accent_lt?: String
  accent_lte?: String
  accent_gt?: String
  accent_gte?: String
  accent_contains?: String
  accent_not_contains?: String
  accent_starts_with?: String
  accent_not_starts_with?: String
  accent_ends_with?: String
  accent_not_ends_with?: String
  background?: String
  background_not?: String
  background_in?: String[] | String
  background_not_in?: String[] | String
  background_lt?: String
  background_lte?: String
  background_gt?: String
  background_gte?: String
  background_contains?: String
  background_not_contains?: String
  background_starts_with?: String
  background_not_starts_with?: String
  background_ends_with?: String
  background_not_ends_with?: String
  AND?: ThemeColorsWhereInput[] | ThemeColorsWhereInput
  OR?: ThemeColorsWhereInput[] | ThemeColorsWhereInput
  NOT?: ThemeColorsWhereInput[] | ThemeColorsWhereInput
}

export interface ThemeColorsUpsertNestedInput {
  update: ThemeColorsUpdateDataInput
  create: ThemeColorsCreateInput
}

export interface ConnectionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType
  updatedFields_contains?: String
  updatedFields_contains_every?: String[] | String
  updatedFields_contains_some?: String[] | String
  node?: ConnectionWhereInput
  AND?: ConnectionSubscriptionWhereInput[] | ConnectionSubscriptionWhereInput
  OR?: ConnectionSubscriptionWhereInput[] | ConnectionSubscriptionWhereInput
  NOT?: ConnectionSubscriptionWhereInput[] | ConnectionSubscriptionWhereInput
}

export interface ThemeUpsertWithoutGuildInput {
  update: ThemeUpdateWithoutGuildDataInput
  create: ThemeCreateWithoutGuildInput
}

export interface GuildCreateOneWithoutThemeInput {
  create?: GuildCreateWithoutThemeInput
  connect?: GuildWhereUniqueInput
}

export interface GuildGuestUpdateManyDataInput {
  nickname?: String
}

export interface GuildGuestUpdateManyWithWhereNestedInput {
  where: GuildGuestScalarWhereInput
  data: GuildGuestUpdateManyDataInput
}

export interface GuildGuestScalarWhereInput {
  nickname?: String
  nickname_not?: String
  nickname_in?: String[] | String
  nickname_not_in?: String[] | String
  nickname_lt?: String
  nickname_lte?: String
  nickname_gt?: String
  nickname_gte?: String
  nickname_contains?: String
  nickname_not_contains?: String
  nickname_starts_with?: String
  nickname_not_starts_with?: String
  nickname_ends_with?: String
  nickname_not_ends_with?: String
  AND?: GuildGuestScalarWhereInput[] | GuildGuestScalarWhereInput
  OR?: GuildGuestScalarWhereInput[] | GuildGuestScalarWhereInput
  NOT?: GuildGuestScalarWhereInput[] | GuildGuestScalarWhereInput
}

export interface GuildGuestUpdateManyWithoutGuildInput {
  create?:
    | GuildGuestCreateWithoutGuildInput[]
    | GuildGuestCreateWithoutGuildInput
  deleteMany?: GuildGuestScalarWhereInput[] | GuildGuestScalarWhereInput
  updateMany?:
    | GuildGuestUpdateManyWithWhereNestedInput[]
    | GuildGuestUpdateManyWithWhereNestedInput
}

export interface ConnectionUpdateManyDataInput {
  type?: String
  data?: String
}

export interface GuildUpdateWithoutThemeDataInput {
  guests?: GuildGuestUpdateManyWithoutGuildInput
  bans?: GuildBanUpdateManyWithoutGuildInput
}

export interface ProfileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType
  updatedFields_contains?: String
  updatedFields_contains_every?: String[] | String
  updatedFields_contains_some?: String[] | String
  node?: ProfileWhereInput
  AND?: ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput
  OR?: ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput
  NOT?: ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput
}

export interface ThemeColorsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType
  updatedFields_contains?: String
  updatedFields_contains_every?: String[] | String
  updatedFields_contains_some?: String[] | String
  node?: ThemeColorsWhereInput
  AND?: ThemeColorsSubscriptionWhereInput[] | ThemeColorsSubscriptionWhereInput
  OR?: ThemeColorsSubscriptionWhereInput[] | ThemeColorsSubscriptionWhereInput
  NOT?: ThemeColorsSubscriptionWhereInput[] | ThemeColorsSubscriptionWhereInput
}

export interface ConnectionUpdateManyInput {
  create?: ConnectionCreateInput[] | ConnectionCreateInput
  deleteMany?: ConnectionScalarWhereInput[] | ConnectionScalarWhereInput
  updateMany?:
    | ConnectionUpdateManyWithWhereNestedInput[]
    | ConnectionUpdateManyWithWhereNestedInput
}

export interface NodeNode {
  id: ID_Output
}

export interface ThemeColorsPreviousValues {
  primary: String
  accent: String
  background: String
}

export interface ThemeColorsPreviousValuesPromise
  extends Promise<ThemeColorsPreviousValues>,
    Fragmentable {
  primary: () => Promise<String>
  accent: () => Promise<String>
  background: () => Promise<String>
}

export interface ThemeColorsPreviousValuesSubscription
  extends Promise<AsyncIterator<ThemeColorsPreviousValues>>,
    Fragmentable {
  primary: () => Promise<AsyncIterator<String>>
  accent: () => Promise<AsyncIterator<String>>
  background: () => Promise<AsyncIterator<String>>
}

export interface GuildEdge {
  node: Guild
  cursor: String
}

export interface GuildEdgePromise extends Promise<GuildEdge>, Fragmentable {
  node: <T = GuildPromise>() => T
  cursor: () => Promise<String>
}

export interface GuildEdgeSubscription
  extends Promise<AsyncIterator<GuildEdge>>,
    Fragmentable {
  node: <T = GuildSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface Guild {
  id: ID_Output
}

export interface GuildPromise extends Promise<Guild>, Fragmentable {
  id: () => Promise<ID_Output>
  theme: <T = ThemePromise>() => T
  guests: <T = FragmentableArray<GuildGuest>>(
    args?: {
      where?: GuildGuestWhereInput
      orderBy?: GuildGuestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => T
  bans: <T = FragmentableArray<GuildBan>>(
    args?: {
      where?: GuildBanWhereInput
      orderBy?: GuildBanOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => T
}

export interface GuildSubscription
  extends Promise<AsyncIterator<Guild>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  theme: <T = ThemeSubscription>() => T
  guests: <T = Promise<AsyncIterator<GuildGuestSubscription>>>(
    args?: {
      where?: GuildGuestWhereInput
      orderBy?: GuildGuestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => T
  bans: <T = Promise<AsyncIterator<GuildBanSubscription>>>(
    args?: {
      where?: GuildBanWhereInput
      orderBy?: GuildBanOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => T
}

export interface GuildConnection {
  pageInfo: PageInfo
  edges: GuildEdge[]
}

export interface GuildConnectionPromise
  extends Promise<GuildConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<GuildEdge>>() => T
  aggregate: <T = AggregateGuildPromise>() => T
}

export interface GuildConnectionSubscription
  extends Promise<AsyncIterator<GuildConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<GuildEdgeSubscription>>>() => T
  aggregate: <T = AggregateGuildSubscription>() => T
}

export interface Theme {
  id: ID_Output
  css: String
}

export interface ThemePromise extends Promise<Theme>, Fragmentable {
  id: () => Promise<ID_Output>
  guild: <T = GuildPromise>() => T
  css: () => Promise<String>
  colors: <T = ThemeColorsPromise>() => T
}

export interface ThemeSubscription
  extends Promise<AsyncIterator<Theme>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  guild: <T = GuildSubscription>() => T
  css: () => Promise<AsyncIterator<String>>
  colors: <T = ThemeColorsSubscription>() => T
}

export interface ThemeColorsSubscriptionPayload {
  mutation: MutationType
  node: ThemeColors
  updatedFields: String[]
  previousValues: ThemeColorsPreviousValues
}

export interface ThemeColorsSubscriptionPayloadPromise
  extends Promise<ThemeColorsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = ThemeColorsPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = ThemeColorsPreviousValuesPromise>() => T
}

export interface ThemeColorsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ThemeColorsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = ThemeColorsSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = ThemeColorsPreviousValuesSubscription>() => T
}

export interface ThemeSubscriptionPayload {
  mutation: MutationType
  node: Theme
  updatedFields: String[]
  previousValues: ThemePreviousValues
}

export interface ThemeSubscriptionPayloadPromise
  extends Promise<ThemeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = ThemePromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = ThemePreviousValuesPromise>() => T
}

export interface ThemeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ThemeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = ThemeSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = ThemePreviousValuesSubscription>() => T
}

export interface ThemeColors {
  primary: String
  accent: String
  background: String
}

export interface ThemeColorsPromise extends Promise<ThemeColors>, Fragmentable {
  primary: () => Promise<String>
  accent: () => Promise<String>
  background: () => Promise<String>
}

export interface ThemeColorsSubscription
  extends Promise<AsyncIterator<ThemeColors>>,
    Fragmentable {
  primary: () => Promise<AsyncIterator<String>>
  accent: () => Promise<AsyncIterator<String>>
  background: () => Promise<AsyncIterator<String>>
}

export interface BatchPayload {
  count: Long
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>
}

export interface AggregateThemeColors {
  count: Int
}

export interface AggregateThemeColorsPromise
  extends Promise<AggregateThemeColors>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateThemeColorsSubscription
  extends Promise<AsyncIterator<AggregateThemeColors>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface ThemeColorsConnection {
  pageInfo: PageInfo
  edges: ThemeColorsEdge[]
}

export interface ThemeColorsConnectionPromise
  extends Promise<ThemeColorsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<ThemeColorsEdge>>() => T
  aggregate: <T = AggregateThemeColorsPromise>() => T
}

export interface ThemeColorsConnectionSubscription
  extends Promise<AsyncIterator<ThemeColorsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<ThemeColorsEdgeSubscription>>>() => T
  aggregate: <T = AggregateThemeColorsSubscription>() => T
}

export interface ThemePreviousValues {
  id: ID_Output
  css: String
}

export interface ThemePreviousValuesPromise
  extends Promise<ThemePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  css: () => Promise<String>
}

export interface ThemePreviousValuesSubscription
  extends Promise<AsyncIterator<ThemePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  css: () => Promise<AsyncIterator<String>>
}

export interface AggregateTheme {
  count: Int
}

export interface AggregateThemePromise
  extends Promise<AggregateTheme>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateThemeSubscription
  extends Promise<AsyncIterator<AggregateTheme>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface ConnectionSubscriptionPayload {
  mutation: MutationType
  node: Connection
  updatedFields: String[]
  previousValues: ConnectionPreviousValues
}

export interface ConnectionSubscriptionPayloadPromise
  extends Promise<ConnectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = ConnectionPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = ConnectionPreviousValuesPromise>() => T
}

export interface ConnectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ConnectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = ConnectionSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = ConnectionPreviousValuesSubscription>() => T
}

export interface ThemeConnection {
  pageInfo: PageInfo
  edges: ThemeEdge[]
}

export interface ThemeConnectionPromise
  extends Promise<ThemeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<ThemeEdge>>() => T
  aggregate: <T = AggregateThemePromise>() => T
}

export interface ThemeConnectionSubscription
  extends Promise<AsyncIterator<ThemeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<ThemeEdgeSubscription>>>() => T
  aggregate: <T = AggregateThemeSubscription>() => T
}

export interface ConnectionPreviousValues {
  type: String
  data: String
}

export interface ConnectionPreviousValuesPromise
  extends Promise<ConnectionPreviousValues>,
    Fragmentable {
  type: () => Promise<String>
  data: () => Promise<String>
}

export interface ConnectionPreviousValuesSubscription
  extends Promise<AsyncIterator<ConnectionPreviousValues>>,
    Fragmentable {
  type: () => Promise<AsyncIterator<String>>
  data: () => Promise<AsyncIterator<String>>
}

export interface AggregateProfile {
  count: Int
}

export interface AggregateProfilePromise
  extends Promise<AggregateProfile>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateProfileSubscription
  extends Promise<AsyncIterator<AggregateProfile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface GuildBan {
  type: String
  data: String
}

export interface GuildBanPromise extends Promise<GuildBan>, Fragmentable {
  guild: <T = GuildPromise>() => T
  type: () => Promise<String>
  data: () => Promise<String>
}

export interface GuildBanSubscription
  extends Promise<AsyncIterator<GuildBan>>,
    Fragmentable {
  guild: <T = GuildSubscription>() => T
  type: () => Promise<AsyncIterator<String>>
  data: () => Promise<AsyncIterator<String>>
}

export interface ProfileConnection {
  pageInfo: PageInfo
  edges: ProfileEdge[]
}

export interface ProfileConnectionPromise
  extends Promise<ProfileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<ProfileEdge>>() => T
  aggregate: <T = AggregateProfilePromise>() => T
}

export interface ProfileConnectionSubscription
  extends Promise<AsyncIterator<ProfileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<ProfileEdgeSubscription>>>() => T
  aggregate: <T = AggregateProfileSubscription>() => T
}

export interface GuildSubscriptionPayload {
  mutation: MutationType
  node: Guild
  updatedFields: String[]
  previousValues: GuildPreviousValues
}

export interface GuildSubscriptionPayloadPromise
  extends Promise<GuildSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = GuildPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = GuildPreviousValuesPromise>() => T
}

export interface GuildSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GuildSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = GuildSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = GuildPreviousValuesSubscription>() => T
}

export interface AggregateGuildGuest {
  count: Int
}

export interface AggregateGuildGuestPromise
  extends Promise<AggregateGuildGuest>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateGuildGuestSubscription
  extends Promise<AsyncIterator<AggregateGuildGuest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface GuildPreviousValues {
  id: ID_Output
}

export interface GuildPreviousValuesPromise
  extends Promise<GuildPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
}

export interface GuildPreviousValuesSubscription
  extends Promise<AsyncIterator<GuildPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
}

export interface GuildGuestConnection {
  pageInfo: PageInfo
  edges: GuildGuestEdge[]
}

export interface GuildGuestConnectionPromise
  extends Promise<GuildGuestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<GuildGuestEdge>>() => T
  aggregate: <T = AggregateGuildGuestPromise>() => T
}

export interface GuildGuestConnectionSubscription
  extends Promise<AsyncIterator<GuildGuestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<GuildGuestEdgeSubscription>>>() => T
  aggregate: <T = AggregateGuildGuestSubscription>() => T
}

export interface ConnectionEdge {
  node: Connection
  cursor: String
}

export interface ConnectionEdgePromise
  extends Promise<ConnectionEdge>,
    Fragmentable {
  node: <T = ConnectionPromise>() => T
  cursor: () => Promise<String>
}

export interface ConnectionEdgeSubscription
  extends Promise<AsyncIterator<ConnectionEdge>>,
    Fragmentable {
  node: <T = ConnectionSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface GuildBanEdge {
  node: GuildBan
  cursor: String
}

export interface GuildBanEdgePromise
  extends Promise<GuildBanEdge>,
    Fragmentable {
  node: <T = GuildBanPromise>() => T
  cursor: () => Promise<String>
}

export interface GuildBanEdgeSubscription
  extends Promise<AsyncIterator<GuildBanEdge>>,
    Fragmentable {
  node: <T = GuildBanSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface GuildBanSubscriptionPayload {
  mutation: MutationType
  node: GuildBan
  updatedFields: String[]
  previousValues: GuildBanPreviousValues
}

export interface GuildBanSubscriptionPayloadPromise
  extends Promise<GuildBanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = GuildBanPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = GuildBanPreviousValuesPromise>() => T
}

export interface GuildBanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GuildBanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = GuildBanSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = GuildBanPreviousValuesSubscription>() => T
}

export interface AggregateGuild {
  count: Int
}

export interface AggregateGuildPromise
  extends Promise<AggregateGuild>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateGuildSubscription
  extends Promise<AsyncIterator<AggregateGuild>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface GuildBanPreviousValues {
  type: String
  data: String
}

export interface GuildBanPreviousValuesPromise
  extends Promise<GuildBanPreviousValues>,
    Fragmentable {
  type: () => Promise<String>
  data: () => Promise<String>
}

export interface GuildBanPreviousValuesSubscription
  extends Promise<AsyncIterator<GuildBanPreviousValues>>,
    Fragmentable {
  type: () => Promise<AsyncIterator<String>>
  data: () => Promise<AsyncIterator<String>>
}

export interface Connection {
  type: String
  data: String
}

export interface ConnectionPromise extends Promise<Connection>, Fragmentable {
  type: () => Promise<String>
  data: () => Promise<String>
}

export interface ConnectionSubscription
  extends Promise<AsyncIterator<Connection>>,
    Fragmentable {
  type: () => Promise<AsyncIterator<String>>
  data: () => Promise<AsyncIterator<String>>
}

export interface Profile {
  id: ID_Output
  username: String
  avatarURL: String
  email?: String
}

export interface ProfilePromise extends Promise<Profile>, Fragmentable {
  id: () => Promise<ID_Output>
  username: () => Promise<String>
  avatarURL: () => Promise<String>
  connections: <T = FragmentableArray<Connection>>(
    args?: {
      where?: ConnectionWhereInput
      orderBy?: ConnectionOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => T
  email: () => Promise<String>
}

export interface ProfileSubscription
  extends Promise<AsyncIterator<Profile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  username: () => Promise<AsyncIterator<String>>
  avatarURL: () => Promise<AsyncIterator<String>>
  connections: <T = Promise<AsyncIterator<ConnectionSubscription>>>(
    args?: {
      where?: ConnectionWhereInput
      orderBy?: ConnectionOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
    }
  ) => T
  email: () => Promise<AsyncIterator<String>>
}

export interface ConnectionConnection {
  pageInfo: PageInfo
  edges: ConnectionEdge[]
}

export interface ConnectionConnectionPromise
  extends Promise<ConnectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<ConnectionEdge>>() => T
  aggregate: <T = AggregateConnectionPromise>() => T
}

export interface ConnectionConnectionSubscription
  extends Promise<AsyncIterator<ConnectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<ConnectionEdgeSubscription>>>() => T
  aggregate: <T = AggregateConnectionSubscription>() => T
}

export interface GuildGuestSubscriptionPayload {
  mutation: MutationType
  node: GuildGuest
  updatedFields: String[]
  previousValues: GuildGuestPreviousValues
}

export interface GuildGuestSubscriptionPayloadPromise
  extends Promise<GuildGuestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = GuildGuestPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = GuildGuestPreviousValuesPromise>() => T
}

export interface GuildGuestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GuildGuestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = GuildGuestSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = GuildGuestPreviousValuesSubscription>() => T
}

export interface PageInfo {
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor?: String
  endCursor?: String
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>
  hasPreviousPage: () => Promise<Boolean>
  startCursor: () => Promise<String>
  endCursor: () => Promise<String>
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>
  startCursor: () => Promise<AsyncIterator<String>>
  endCursor: () => Promise<AsyncIterator<String>>
}

export interface GuildGuestPreviousValues {
  nickname?: String
}

export interface GuildGuestPreviousValuesPromise
  extends Promise<GuildGuestPreviousValues>,
    Fragmentable {
  nickname: () => Promise<String>
}

export interface GuildGuestPreviousValuesSubscription
  extends Promise<AsyncIterator<GuildGuestPreviousValues>>,
    Fragmentable {
  nickname: () => Promise<AsyncIterator<String>>
}

export interface AggregateGuildBan {
  count: Int
}

export interface AggregateGuildBanPromise
  extends Promise<AggregateGuildBan>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateGuildBanSubscription
  extends Promise<AsyncIterator<AggregateGuildBan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface ThemeColorsEdge {
  node: ThemeColors
  cursor: String
}

export interface ThemeColorsEdgePromise
  extends Promise<ThemeColorsEdge>,
    Fragmentable {
  node: <T = ThemeColorsPromise>() => T
  cursor: () => Promise<String>
}

export interface ThemeColorsEdgeSubscription
  extends Promise<AsyncIterator<ThemeColorsEdge>>,
    Fragmentable {
  node: <T = ThemeColorsSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateConnection {
  count: Int
}

export interface AggregateConnectionPromise
  extends Promise<AggregateConnection>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateConnectionSubscription
  extends Promise<AsyncIterator<AggregateConnection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface ProfilePreviousValues {
  id: ID_Output
  username: String
  avatarURL: String
  email?: String
}

export interface ProfilePreviousValuesPromise
  extends Promise<ProfilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  username: () => Promise<String>
  avatarURL: () => Promise<String>
  email: () => Promise<String>
}

export interface ProfilePreviousValuesSubscription
  extends Promise<AsyncIterator<ProfilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  username: () => Promise<AsyncIterator<String>>
  avatarURL: () => Promise<AsyncIterator<String>>
  email: () => Promise<AsyncIterator<String>>
}

export interface ProfileSubscriptionPayload {
  mutation: MutationType
  node: Profile
  updatedFields: String[]
  previousValues: ProfilePreviousValues
}

export interface ProfileSubscriptionPayloadPromise
  extends Promise<ProfileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = ProfilePromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = ProfilePreviousValuesPromise>() => T
}

export interface ProfileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProfileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = ProfileSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = ProfilePreviousValuesSubscription>() => T
}

export interface GuildGuest {
  nickname?: String
}

export interface GuildGuestPromise extends Promise<GuildGuest>, Fragmentable {
  guild: <T = GuildPromise>() => T
  profile: <T = ProfilePromise>() => T
  nickname: () => Promise<String>
}

export interface GuildGuestSubscription
  extends Promise<AsyncIterator<GuildGuest>>,
    Fragmentable {
  guild: <T = GuildSubscription>() => T
  profile: <T = ProfileSubscription>() => T
  nickname: () => Promise<AsyncIterator<String>>
}

export interface ThemeEdge {
  node: Theme
  cursor: String
}

export interface ThemeEdgePromise extends Promise<ThemeEdge>, Fragmentable {
  node: <T = ThemePromise>() => T
  cursor: () => Promise<String>
}

export interface ThemeEdgeSubscription
  extends Promise<AsyncIterator<ThemeEdge>>,
    Fragmentable {
  node: <T = ThemeSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface GuildBanConnection {
  pageInfo: PageInfo
  edges: GuildBanEdge[]
}

export interface GuildBanConnectionPromise
  extends Promise<GuildBanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<GuildBanEdge>>() => T
  aggregate: <T = AggregateGuildBanPromise>() => T
}

export interface GuildBanConnectionSubscription
  extends Promise<AsyncIterator<GuildBanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<GuildBanEdgeSubscription>>>() => T
  aggregate: <T = AggregateGuildBanSubscription>() => T
}

export interface GuildGuestEdge {
  node: GuildGuest
  cursor: String
}

export interface GuildGuestEdgePromise
  extends Promise<GuildGuestEdge>,
    Fragmentable {
  node: <T = GuildGuestPromise>() => T
  cursor: () => Promise<String>
}

export interface GuildGuestEdgeSubscription
  extends Promise<AsyncIterator<GuildGuestEdge>>,
    Fragmentable {
  node: <T = GuildGuestSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface ProfileEdge {
  node: Profile
  cursor: String
}

export interface ProfileEdgePromise extends Promise<ProfileEdge>, Fragmentable {
  node: <T = ProfilePromise>() => T
  cursor: () => Promise<String>
}

export interface ProfileEdgeSubscription
  extends Promise<AsyncIterator<ProfileEdge>>,
    Fragmentable {
  node: <T = ProfileSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number
export type ID_Output = string

export type Long = string

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: 'Connection',
    embedded: false
  },
  {
    name: 'Guild',
    embedded: false
  },
  {
    name: 'GuildBan',
    embedded: false
  },
  {
    name: 'GuildGuest',
    embedded: false
  },
  {
    name: 'Profile',
    embedded: false
  },
  {
    name: 'Theme',
    embedded: false
  },
  {
    name: 'ThemeColors',
    embedded: false
  }
]

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://eu1.prisma.sh/sam-denty-1336dd/widgetbot/dev`
})
export const prisma = new Prisma()
